{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Learn R for Journal entry analysis\n",
      "author": [],
      "contents": "\nPrerequisite\nRstudio R | Docker | Rocker | 윈도우즈에서 도커로 Rstudio 환경 사용하기 | tidyverse 와 같이 정상적으로 설치되었다는 것을 전제하여 다음에 소개하는 Code를 스크립트 창에 조금씩 써보거나 복사해서 붙여 넣는 방식으로 실습한다.\nJournal Entry Test에 사용한 프로그램\n\n\nR.version\n\n\nData 준비하기\nRstudio에는 작업 환경을 분할해서 관리할 수 있는 Project 기능이 있다. New Project로 Project를 생성하고 Project를 열어서 작업을 하면 작업 환경이 지정 되고 폴더도 생성되어 그 안에서 독립된 환경을 갖추어 작업 할 수 있다.\n다운로드\n다운로드 링크에서 우측 상단의 ↓ Code 을 클릭하여 Download ZIP 을 통해서 파일을 다운로드 받는다.\n다운로드 받은 파일은 압축을 풀어 je.csv, CYTB.xlsx, PYTB.xlsx 세 개의 파일을 생성한 프로젝트 폴더에 옮겨 담는다.\nPackage Load\n\n\nlibrary(tidyverse)  \n\n\ntidyverse 패키지를 불러온다. 이렇게 명시해 주면 순수 R 언어에 없는 기능들이 포함된 tidyverse 패키지의 기능을 R에 붙인다고 생각하면 된다.\nCode로 바로 내려받기\n다음의 코드를 사용하면 Github에 올려져 있는 텍스트 파일을 바로 내려 받을 수 있다.\n교육용으로 활용할 수는 있겠지만 현실에서는 파일이 웹에 올려져 있지 않고 Private 환경에서 전달 받을 것이므로 실제 상황을 감안하면 현실적이지 않다.\n다만 연수 목적으로 편의상 활용할 수는 있겠다.\n\n\nje_raw <- readr::read_csv(\"https://raw.githubusercontent.com/joy-hhh/R_for_JE_test/main/je.csv\")\n\n\n시작\n전체 과정은 R에 파일을 불러와서 작업하고 결과물을 워드 파일로 생성하는 것으로 마친다.\nFile - New File - Quarto Document…\nWord 선택\nCreate\nVisual → Source 로 변경 선택\neditor: visual → editor: source 로 수정\n설정 마크에를 눌러서 Use Visual Editor를 해제하고 Chunk Output in Console을 선택\nTest에 대한 기술(Description)\nStep 1. 테스트 개요 및 목적\n재무제표에 대한 회계감사의 일환으로 감사대상기간 동안 발생한 모든 전표 데이터에 대한 무결성 및 비경상적인 거래가 존재하는지를 검증\n계정명(FSLI) : 전체 계정\n기준일 (Coverage date) : 2023-01-01 ~ 2023-12-31\n테스트되는 경영자의 주장 (Assertion) : 완전성 (C),정확성 (A),기간귀속구분 (CO),실재성 (E/O),권리 (R),공시(PD),평가(V)\nStep 2. Test 대상 모집단\n전체 전표를 포함하는 분개장.\n모집단의 완전성 확인 : Step 5. Test 결과의 A01, A02, A03 참조\nStep 3. 오류의 정의\n재무보고 프로세스 관련, 부적절하거나 비경상적인 분개 및 수정사항\nStep 4. Test 방법\nA01 . Data Integrity 검증 - 데이터 유효성을 검증하고, record에 대한 이해를 위한 절차\n전표 데이터의 회계기간이 당해년도에 포함되는지 여부 검토\n전표 주요 필드값의 누락 여부 검토를 통한 data integrity 검토\nA02. 전표번호 별 차대변 일치검증\n전표번호 별 차변금액과 대변금액이 일치하는지 확인하여 전표 데이터의 완전성을 검토\n차변금액과 대변금액이 일치하지 않을 경우 해당 전표를 추출하여 회사 측과 확인\nA03. 시산표 Reconciliation 검증(Trial Balance Rollforward Test)\n기초 F/S잔액에 수령한 모든 전표의 계정과목 별 합계금액을 반영하여 도출한 기말 F/S 잔액과 회사 제시 F/S와의 일치 여부 검토\nB01. 매출의 상대계정분석(매출과 연관성이 낮은 계정이 포함된 비정상적인 거래)\n매출에 대한 상대계정분석 결과 비정상적으로 처리된 회계처리가 있는지 검토하고 해당 전표 중 특정 금액 이상인 건을 추출하여 검토\nStep 5. Test 결과\n이하의 Test 절차\n1. Journal Entry Data의 분개 금액 열이 두 줄로 되어 있는 경우\n더존의 경우 분개장에 분개 금액이 차변금액과 대변금액 두 줄로 되어 있다. 왼쪽의 차변금액에 금액이 들어 있으면 대변금액은 비어 있고 대변금액에 숫자가 들어 있으면 차변금액이 비어 있다. 이러한 모양의 Journal Entry Data의 경우를 먼저 실습한다.\n파일 불러오기 (Data 읽기)\n코드 블럭을 설정하거나 프롬프트가 위치한 행에서 ’Ctrl + Enter’를 누르면 선택 부분이 Console로 들어가서 실행된다.\nR은 Rstudio의 이 스크립트 창에서 Console에 Code를 던져 주면서 실행하는 방식이 좋다.\n\n\nje_raw <- read_csv('je.csv', locale=locale('ko',encoding='euc-kr'))  \nprint(je_raw)  \n\n\n프로젝트 폴더 경로에 전표 파일을 두고 읽는 명령으로 읽어와서 je_raw라고 이름 붙인다.(이름 붙인 것을 객체라고 한다. je_raw 객체) 윈도우즈 기준의 파일의 경우 파일명 뒤의 encoding 명시를 해주면 글자가 깨지지 않고 읽어온다. 윈도우 기준의 한글 형식에 맞출 수 있다. read_csv 명령 함수는 utf-8 encoding을 기본으로 하기 때문에 한글이 깨질 수 있다. 2기가 정도 되는 data file이 100초 정도 걸린다. (컴퓨터 성능에 따라서 다르다.) 몇십메가 정도의 data file은 몇초가 되기 전에 읽어버린다.1\n이름 붙인 je_raw 객체를 Console에 나타내 확인한다.\n프로그램에 맞추어 열 이름 변경\nchange column name\n열 이름은 회사마다 고유의 이름을 정해서 사용하므로 모두 다를 수가 있다. 각기 다른 열 이름에 맞춰서 이 후에 진행될 프로그램 전체에서 열 이름을 바꿔주는 것은 번거롭기도 하지만 오류를 발생시킬 우려 또한 높아진다. 따라서 미리 프로그램 해 놓은 코드에 그대로 적용하기 위하여 Data의 열 이름을 프로그램에서 사용한 이름으로 맞춰 변경시킨다.\n\n\nje_tbl <- rename(je_raw, JEDATE = 전표일자,\n                         JENO = 전표번호,\n                         DR = 차변금액,\n                         CR = 대변금액,\n                         ACCTCD = 계정코드,\n                         ACCT_NM = 계정과목명)\n\n\n해당 전표에는 차변금액이 비어 있거나 대변금액에 비어 있는 결측값이 많이 포함되어 있다. 이 결측값들을 그대로 두면 연산하기 불편해진다. 숫자형 자료와 NA를 합하는 등의 연산을 수행하면 NA를 반환하기 때문이다. 결측값을 0으로 변경하고 날짜 열의 숫자를 날짜형태로 변경한다. 또한 월별 추세분석을 하기 위하여 월 구분자로 month 열을 추가한다. 계정코드 ACCTCD는 factor 형태로 변경하고 전표번호는 문자형으로 변경한다.\n\n\nje_tbl <- je_tbl %>% \n  mutate(across(DR:CR, \\(x) ifelse(is.na(x), 0, x)),\n         JEDATE = ymd(JEDATE),\n         month = as_factor(month(JEDATE)),\n         ACCTCD = as_factor(ACCTCD),\n         JENO = as.character(JENO)\n)\n\n\n정상 전표가 메모리에 Load 되었는지 확인하기 위하여 먼저 차변금액과 대변금액 각각의 합계를 출력하고 같은지 확인한다.\n\n\n# 차변금액 합계\nsum(je_tbl$DR)\n# 대변금액 합계\nsum(je_tbl$CR)\n# 차변금액과 대변금액 합계가 같은지 확인\nsum(je_tbl$DR) == sum(je_tbl$CR)\n\n\nA01 Data Integrity Test\n\n\ncolnames(je_tbl)\nstr(je_tbl)\ntable(is.na(je_tbl))  \nsapply(je_tbl, function(x) sum(is.na(je_tbl)))\n\nmax(je_tbl$JEDATE)\nmin(je_tbl$JEDATE)\n\n\n읽어온 je_tbl의 변수명(열 이름, column명)을 확인한다.\nje_tbl의 구조를 파악한다.\nje_tbl에 있는 Null 값을 집계한다.\nje_tbl의 변수명에 따른 Null값을 각각 집계하여 보여준다.\n전표 일자의 가장 큰 값을 나타낸다. 날짜열의 가장 큰 값이 해당 연도를 넘어가지 않는지 확인한다.\n전표 일자의 가장 작은 값을 나타낸다. 날짜열의 가장 작은 값이 해당 연도 이전은 아닌지 확인한다.\nskim 함수를 사용하여 Data skim 확인\nR은 함수형 프로그래밍으로 미리 작성된 좋은 함수들이 많이 있다. skimr 패키지를 설치하고 skim 함수를 사용하면 데이터의 전체적인 구조를 한번에 확인할 수 있다.\n\n\nif(!require(skimr)){install.packages(\"skimr\");library(skimr)}\nskim(je_tbl)\n\n\nA02 전표번호 별 차대변 일치검증\n\n\nA02 <- je_tbl %>%  \n    select(JENO, DR, CR) %>%  \n    # mutate_all(~replace(., is.na(.), 0)) %>%  \n    group_by(JENO) %>% \n    summarise(DR_sum=sum(DR),\n              CR_sum=sum(CR)) %>%  \n    mutate(Differ= DR_sum - CR_sum)\n\nprint(A02)\nA02 %>% filter(Differ != 0) %>% nrow() \n\n\n전표번호, 차변금액, 대변금액 열을 선택(select)한다. 선택한 세 개의 열에 Null 값 (NA)이 있으면 0으로 모두 바꾼다.(mutate_all) Null 값(NA)은 계산의 결과가 무조건 NA가 되면서 원하지 않은 불편한 결론을 내기 때문이다. 전표번호별로 묶어서(group_by) 전표번호별 차변의 합계를 DR_sum의 열 이름으로 전표번호별 대변의 합계를 CR_sum의 열 이름으로 정리한다.(summarise) 전표번호별 차변 금액과 대변 금액 합계를 각각 차이를 계산하여 Differ라는 열 이름으로 추가(mutate)한다.\n전표번호별 차변 금액 합계와 대변 금액 합계의 차이 Differ열의 전체 합계를 계산한다.\n계산한 차이의 합계를 확인한다.\nA03 시산표 Reconciliation 검증(Trial Balance Rollforward Test)\n시산표 검증에는 추가로 시산표 파일에서 Data를 읽어와야 한다.\n시산표는 엑셀로 되어 있기 쉬우므로 엑셀 파일에서 바로 읽어온다. 전표 파일은 엑셀로 읽으면 csv 파일로 읽어 오는 것보다 훨씬 오래 걸린다. 대용량 Data는 엑셀이 담을 수 있는 행을 넘어버릴 것이므로 애초에 엑셀일 수가 없다. 시산표 정도는 프린터로 종이에 프린트 해도 두세장이면 담아 낼 수 있으므로 엑셀 파일로 바로 읽어도 상관 없다. 명령을 ’Ctrl + Enter’로 누르는 즉시 읽어들인다.\n\n\nif(!require(readxl)){install.packages(\"readxl\");library(readxl)}   \n      \ncytb_raw <- read_excel('CYTB.xlsx')\npytb_raw <- read_excel('PYTB.xlsx')\ncolSums(is.na(cytb_raw))\ncolSums(is.na(pytb_raw))\n\n\n엑셀을 읽기 위한 기능을 R에 부착한다. 생김새가 복잡한 이유는 readxl패키지가 설치되어 있지 않은 경우에는 설치하고 이미 설치되어 있는 경우에는 설치하지 않고 불러오라는 의미를 내포하였기 때문이다. 아직 readxl 패키지를 설치하지 않았으므로 바로 library 명령을 썼다가 오류가 나서 놀라서 충격 받지 않기를 바라는 배려이다.\n엑셀 파일 형태의 당기 시산표를 읽어들인다. (R이 칼질하기 좋게 R의 도마에 올린다.)\n엑셀 파일 형태의 전기 시산표를 읽어들인다.\n당기 시산표의 변수별(열 이름)로 NA 갯수를 확인한다.\n전기 시산표의 변수별(열 이름)로 NA 갯수를 확인한다.\nRstudio의 Powerful한 기능 View로 시산표를 볼 수 있다.\n\n\nView(cytb_raw)\n\n\n아주 자연스럽게 느껴지는 엑셀 같은 화면을 만날 수 있다. 물론 읽기 전용이다. 각 변수(열)에 필터 값으로 함축해 볼 수도 있다. 다른 언어에서 찾아 볼 수 없는 독보적인 기능이다. Rstudio는 시원하게 작업중인 중간에 들여다 볼 수가 있다. 무조건 말로만 해야 하는 것이 아니다. 보면서 해야 한다. 말로 하고 듣기도 하지만 볼수도 있어야 당연하다. 우리는 엑셀에 익숙하므로 즉각적으로 표를 보고 싶다. View(je_tbl) 로 전표 데이터를 볼 수도 있고 환경 창에 있는 변수를 마우스 클릭해도 View() 기능이 작동한다.\n\n\ncytb_tbl <- drop_na(cytb_raw, ACCTCD)\npytb_tbl <- drop_na(pytb_raw, ACCTCD)\n\nCYTB_FP <- cytb_tbl %>% \n    slice(1:99)\nCYTB_PL <- cytb_tbl %>% \n    slice(100:n())\nPYTB_FP <- pytb_tbl %>% \n    slice(1:103)\n\ntail(CYTB_FP)\nhead(CYTB_PL)\ntail(PYTB_FP)\n\nCYTB_FP <- full_join(CYTB_FP, PYTB_FP, by='ACCTCD')  %>%  \n    mutate_all(~replace(., is.na(.), 0)) %>% \n    mutate(move = (DRSUM.x - CRSUM.x) -(DRSUM.y - CRSUM.y)) %>% \n    select(ACCTCD, move)\n\nCYTB_PL <- CYTB_PL %>% \n    mutate(move = (DRSUM - CRSUM)) %>% \n    select(ACCTCD, move)\n\nCYTB_move <- bind_rows(CYTB_FP, CYTB_PL)\n\n\n결측값(Null, NA)이 ACCTCD 열에 있었으며 결측값 때문에 어려움이 발생할 수 있으므로 결측을 없애고 시작한다.\n전기 시산표에서도 결측을 없앤다.\n결측을 없애고 나서 View(CYTB) 기능으로 읽어들인 시산표를 보니 99행이 시산표 중 재무상태표의 마지막 행이다. 시산표의 재무상태표 부분을 나누기 위하여 1행 부터 99행까지를 썰어낸다.(slicing)\n시산표의 손익계산서 부분을 뜯어내기 위하여 100행부터 끝까지 썰어낸다.\n시산표에서 썰어낸 당기재무상태표 하단을 확인한다. 재무상태표 끝단이 썰렸는지 확인.\n시산표에서 썰어낸 당기손익계산서 상단을 확인한다. 손익계산서 시작점부터 썰렸는지 확인.\n전기시산표에서 썰어낸 전기재무상태표 하단을 확인한다. 재무상태표 끝단이 썰렸는지 확인.\n전기 시산표의 재무상태표 부분을 썰어낸다. 전기 시산표가 필요한 이유는 시산표의 재무상태표 부분에는 기초잔액이 포함되어 있다. 전표에는 기초잔액이 포함되어 있지 않고 당기의 변동분만을 포함하고 있다. 만약 전표가 기초 잔액을 포함하고 있다면 이 Code는 수정되어야 할 수도 있다. 일반적으로 전표는 당기 변동을 분개로 포함하고 시산표의 재무상태표 부분은 기초잔액과 당기 변동을 포함하여 잔액이 기말 잔액이 되도록 한다. 기초잔액이 없이는 기말 잔액이 존재할 수 없다.\n당기시산표에 전기 시산표의 재무상태표 부분을 계정과목별로 맞춰서 붙인다. 이 때 당기시산표에 있는 계정과 전기시산표에 있는 계정이 모두 포함되도록 붙여야 한다. 전기에 변동이 있었으나 당기에 변동이 없었던 항목이 누락되지 않아야 하기 때문이다.\n시산표의 손익계산서 부분은 당기에 발생한 잔액만 있으면 된다. 재무상태표처럼 기초잔액이라는 개념이 없다.\n재무상태표의 잔액에서 기초잔액을 제거한 결과와 시산표의 손익계산서 부분의 잔액을 합하여 전표에서 당기에 변동이 있었던 금액을 하나로 붙인다.\n\n\nA03 <- je_tbl %>% \n    select(ACCTCD, DR, CR) %>% \n    group_by(ACCTCD) %>% \n    summarise(DR_sum=sum(DR),\n              CR_sum=sum(CR)) %>% \n    ungroup() %>%\n    mutate(ACCTCD = as.character(ACCTCD))\n  \nA03 <- left_join(A03, CYTB_move, by = 'ACCTCD')\n  \nA03 <- A03 %>% mutate_all(~replace(.,is.na(.), 0)) %>% \n    mutate(Differ = (DR_sum - CR_sum - move))\n\nA03 %>% \n    filter(Differ != 0)\n\n\n전표에서 계정과목별 차변금액과 대변금액 합계를 계산하여 준비한다.\n시산표에서 준비한 당기 변동금액(전표에서 계산한 계정과목별 당기 변동 금액)을 전표에서 계산한 차변금액과 대변 금액의 합계에 붙인다.\n결측값의 갯수를 확인한다.\n변수별 결측값의 갯수를 확인한다.\n결측값을 0으로 바꾸고 전표의 차변합계에서 대변합계를 빼서 당기변동분을 계산하고 시산표에서 계산한 당기변동분을 빼서 차이를 낸다.\n차이가 0보다 큰 항목 갯수를 세어 A03_Differ 변수로 지정한다.\nA03 변수에서 차이가 0보다 큰 항목을 찾아 나타낸다. 이익잉여금 항목 하나만 나타나면 이상이 없다고 생각할 수 있다.\nB01 매출의 상대계정분석\n\n\nCorr_Acc = '40401'\nB09_main <- je_tbl %>% filter(ACCTCD == Corr_Acc) %>% \n    select(JENO, ACCTCD)\nB09_Corr <- je_tbl %>% \n    select(JENO, ACCTCD)\n\nB09_all <- semi_join(B09_Corr, B09_main, by = 'JENO')\nB09 <- B09_all %>% filter(!is.na(ACCTCD)) %>% \n    count(ACCTCD)\n\n\n상대계정분석에서 기준이 되는 본계정코드를 설정한다.\n전표 데이터에서 본계정이 포함된 전표번호를 필터링(filter)한다. (행 선택)\n전표 데이터에서 전표번호와 계정코드 열을 선택(select)한다. (열 선택)\n선택한 전표번호와 계정코드에서 본계정이 포함된 전표번호만 남겨서 B09 변수로 지정한다.\n본계정과 상대계정의 전표 갯수를 세어 B09 변수로 지정한다.\nView(B09) 명령으로 확인해 보거나 B09를 Console에 쳐서 확인해 볼 수도 있다. 계정코드를 기준으로 본계정과 상대계정들이 모여 있다. 계정과목명이 보이지 않아 보기에 불편하므로 계정과목명을 붙인다.\n\n\nB09_name <- je_tbl %>% select(ACCTCD, ACCT_NM) %>% distinct()  \nB09 <- left_join(B09, B09_name, by = 'ACCTCD')\n\n\n계정코드와 계정과목명 열을 선택한다. 중복되는 계정과목명을 삭제하고 하나씩만 남긴다.\n계정코드에 맞는 계정과목명을 B09 에 붙인다.\n특이해 보이는 상대계정 전표 확인\n선수금 계정과목이 제품매출과 어울리지 않는 상대과목인 것은 아니지만 특정 계정과목이 포함된 전표를 뽑아내서 확인하는 과정을 실행해 보기 위하여 선수금 계정을 포함하는 전표를 확인해 보고자 한다.\n\n\n## 상대계정분석에 있는 선수금이 포함된 전표번호\ntest <- B09_all %>% \n  filter(ACCTCD == 25900) %>% \n  select(JENO) %>% \n  distinct() %>% \n  pull()\n\nje_tbl %>% \n  filter(JENO %in% test) %>% \n  select(JEDATE, JENO, DR, CR, ACCT_NM, ACCTCD) -> test_tbl\n\nView(test_tbl)\n\n\nwrite file\nR에 파일의 Data를 읽어와서 적절한 분석을 통해 요리가 되었는데 이 요리의 결과물을 다시 파일로 갖고 싶다. 과정을 거쳐 오면서 결정적 증거물은 메모리에 객체로 꼬리표를 남겨 두었다. 이 객체를 파일로 저장하고 싶다면 다음 명령어들로 할 수 있다.\n\n\nA02 %>% write_csv('A02.csv')\nA03 %>% write_csv('A03.csv')\nB09 %>% write_csv('B09.csv')\n\n\n“나는 csv 싫다. 엑셀로 저장할거다.” 하는 마음이라면 다음과 같이 하면 된다.\n\n\nif(!require(writexl)){install.packages(\"writexl\");library(writexl)}  \n\nA02 %>% write_xlsx('A02.xlsx')\nA03 %>% write_xlsx('A03.xlsx')\nB09 %>% write_xlsx('B09.xlsx')\n\n\n2. Journal Entry Data의 분개 금액 열이 한줄로 되어 있는 경우\nDatabase는 비어 있는 관측값이 포함되어 있는 것을 좋아하지 않는다. 금액을 한 줄로 쓰고 옆에 다른 열로 차변 또는 대변을 구분하는 구분자 열을 갖도록 구성하는 경우가 많다. 차변금액과 대변금액으로 두 열로 구성하면 차변값이 있으면 대변값이 결측(비어 있게)되고 대변값이 있으면 차변값이 결측되지만 한 줄로 금액 열을 구성하면 결측이 발생하지 않는다. 이렇게 금액이 한 줄로 들어가고 차대구분자로 차변 또는 대변을 포함하는 경우의 전표 데이터 분석에 대하여 실습한다.\n파일 불러오기 (Data 읽기)\n\n\nje_raw <- readr::read_csv(\"https://raw.githubusercontent.com/joy-hhh/R_for_JE_test/main/je_utf_minimal.csv\")\n\n\n프로그램에 맞추어 열 이름 변경\nchange column name\n\n\nje_tbl <- rename(je_raw, JEDATE = `구 분[기표][년/월/일]`,\n                         JENO = JENO,\n                         amount = amount,\n                         record = Record,\n                         ACCTCD = ACCT_CD,\n                         ACCT_NM = ACCT_NM)\n\n\n전표 데이터에서 열별 NA 갯수 확인\n\n\nje_tbl %>% \n  is.na() %>% \n  colSums()\n\n\n결측값을 0으로 변경하고 날짜 열의 숫자를 날짜형태로 변경한다. 또한 월별 추세분석을 하기 위하여 월 구분자로 month 열을 추가한다. 계정코드 ACCTCD는 factor 형태로 변경하고 전표번호는 문자형으로 변경한다.\n\n\nje_tbl <- je_tbl %>% \n  mutate(across(amount, \\(x) ifelse(is.na(x), 0, x)),\n         JEDATE = ymd(JEDATE),\n         month = as_factor(month(JEDATE)),\n         ACCTCD = as_factor(ACCTCD),\n         JENO = as.character(JENO)\n        )\n\n\n차변합계와 대변합계 금액이 같은지 확인한다.\n\n\n## 차변합계\nsum_DR <- je_tbl %>% \n  filter(record == \"차변\") %>% \n  select(amount) %>% \n  pull() %>% \n  sum()\n\n## 대변합계\nsum_CR <- je_tbl %>% \n  filter(record == \"대변\") %>% \n  select(amount) %>% \n  pull() %>% \n  sum()\n\nprint(\"차변합계와 대변합계가 같은지 확인한다.\")\nprint(\"차변합계와 대변합계가 같은가?\")\nprint(sum_DR == sum_CR)\n\n\nA02 전표번호 별 차대변 일치검증\npivot_wider 함수를 사용하여 차대변 구분자에 따라서 차변합계와 대변합계로 나누어 전표번호별 합계 차이를 계산한다.\n\n\nA02 <- je_tbl %>%  \n  select(JENO, amount, record) %>%  \n  pivot_wider(id_cols = JENO, names_from = record, values_from = amount, values_fn = sum) %>% \n  mutate(Differ= S - H)\n  \nprint(A02)\n\nA02 %>% filter(Differ != 0)   \n\n\nA03 시산표 Reconciliation 검증(Trial Balance Rollforward Test)\n\n\nA03 <- je_tbl %>%  \n  select(ACCTCD, amount, record) %>%  \n  pivot_wider(id_cols = ACCTCD, names_from = record, values_from = amount, values_fn = sum) %>% \n  # join 할때 자료형 일치\n  mutate(ACCTCD = as.character(ACCTCD))\n\nA03 <- left_join(A03, cytb_move, by = 'ACCTCD')\nA03 <- A03 %>% \n  mutate_all(~replace(.,is.na(.), 0)) %>% \n  mutate(Differ = (S - H - move))\n\nac_name <- je_tbl %>% \n  distinct(ACCTCD, ACCT_NM) %>% \n  mutate(ACCTCD=as.character(ACCTCD))\n\nA03 <- left_join(A03, ac_name, by='ACCTCD')\n\nprint(A03)\n\nA03 %>% filter(Differ != 0)\n\n\nConclusion\n전표 분석의 결론을 기재한다.\n(예) 전표 분석 결과 Step3에서 정의한 오류 사항이 발견되지 아니함.\n이 외의 Analysis\n분개 금액 열이 두 줄로 되어 있는 경우 활용을 위해 읽어온다.\n\n\nje_raw <- readr::read_csv(\"https://raw.githubusercontent.com/joy-hhh/R_for_JE_test/main/je.csv\")\n\nje_tbl <- rename(je_raw, JEDATE = 전표일자,\n                         JENO = 전표번호,\n                         DR = 차변금액,\n                         CR = 대변금액,\n                         ACCTCD = 계정코드,\n                         ACCT_NM = 계정과목명)\n\nje_tbl <- je_tbl %>% \n  mutate(across(DR:CR, \\(x) ifelse(is.na(x), 0, x)),\n         JEDATE = ymd(JEDATE),\n         month = as_factor(month(JEDATE)),\n         ACCTCD = as_factor(ACCTCD),\n         JENO = as.character(JENO))\n\n\n벤포드의 법칙\n벤포드의 법칙(Benford’s law)은 정수 1부터 9까지의 숫자 중 어떤 분야의 수치들에서 1부터 9까지의 수 n이 첫 자리 수가 될 확률이 1이 가장 크고 점차 9까지 작아지는 현상을 말한다.\n벤포드의 법칙은 자연과학의 법칙과 같이 항상 성립하는 절대적 진리가 아니라, 상당수의 자료에서 성립하는 경향이 있다는 것을 의미한다. 이제 벤포드의 법칙이 왜 성립하는지 그 이유를 생각해보자. 우리 주변의 자료 중에는 일정한 속도로 증가하는 것이 많다.\n예를 들어 일정한 속도로 자라는 나무가 있다고 하자. 기준이 되는 시점의 나무의 높이를 1이라고 하면, 그 높이가 2배가 되어 2가 될 때까지 상당한 시간이 걸릴 것이다. 이제 나무의 높이가 2에서 3으로 늘어나려면 1.5배가 되어야 하므로 1에서 2로 2배가 될 때까지 걸리는 시간보다 짧아진다.\n마찬가지로 3에서 4로 1.33배 늘어나는 데 걸리는 시간은 더 짧아진다. 결과적으로 볼 때 나무의 높이는 1에서 머무는 시간이 길고, 2에서 3으로 갈수록 머무는 시간이 짧아지게 된다. 이를 표현하는 것이 바로 벤포드의 법칙의 식에 포함된 상용로그라고 할 수 있다.2\n벤포드의 법칙은 포렌식(Digital Forensics)이나 부정 적발 감사 등에서 회계 데이터의 샘플링을 수행할 시 가장 적절한 방법 중 하나이다.\nR CRAN의 benford.analysis 패키지를 활용하여 벤포드 분석\n\n\nif(!require(benford.analysis)){install.packages(\"benford.analysis\");library(benford.analysis)}\n\nje_sales <- je_tbl %>%  \n  filter(ACCTCD == '40401')\n\nje_sales$CR %>% benford()\n\n\n벤포드 분석 결과 Plot 확인\n\n\nbl <- je_sales$CR %>% benford()\nplot(bl)\n\n\n매출액 계정별 비중 확인\n\n\nCYTB_PL %>% \n  slice(1:5) %>% \n  select(ACCTCD) %>% \n  left_join(ac_name, by = 'ACCTCD') %>% \n  left_join(amt_sum, by = 'ACCT_NM') %>% \n  ggplot(aes(x=\"\", y=CR_sum, fill=ACCT_NM)) +\n    geom_bar(stat=\"identity\", width=1) +\n    coord_polar(\"y\", start=0)+\n    scale_y_continuous(labels = scales::comma)+\n    labs(title = \"매출 계정별 비중\",\n         x = \"\",\n         y = \"금액\",\n         fill = \"매출 계정\")\n\n\n매출액 계정 중 제품매출의 비중이 가장 크다.\n매출 월별 추세 분석\n제품매출 월별 추세 분석\n\n\n## 월별 추세 분석 사용자함수 설정\ntrend <- function(acc){\n  je_tbl %>% \n    filter(ACCTCD %in% acc) %>% \n    summarise(\n      amount = sum(CR),\n      .by = month\n    ) %>% ggplot(aes(x=month, y=amount))+\n    geom_col()+\n    scale_y_continuous(labels = scales::comma)+\n    theme_bw()\n}\n\n\n\n\nacc = '40401'  ## 제품매출 계정\ntrend(acc) + \n  geom_hline(yintercept = 700000000)\n\n\n상품매출 월별 추세 분석\n\n\nacc <- \"40100\"\ntrend(acc) + \n  geom_hline(yintercept = 700000000)\n\n\n교육 수입 월별 추세 분석\n\n\nacc <- \"40700\"\ntrend(acc) + \n  geom_hline(yintercept = 700000000)\n\n\n총 매출 계정별 월별 추세 분석 - bar plot (stack)\n\n\nacc <- c(\"40100\", \"40401\", \"40700\", \"41100\", \"41200\")\n\nje_tbl %>% \n    filter(ACCTCD %in% acc) %>% \n    summarise(\n      amount = sum(CR),\n      .by = c(ACCTCD, month)\n    ) %>% \n    ggplot(aes(x=month, y=amount, fill=ACCTCD))+\n    geom_bar(position='stack', stat = \"sum\")+\n    scale_y_continuous(labels = scales::comma)+\n    theme_bw()\n\n\n총 매출 계정별 box plot - 수치형 변수의 범주별 통계요약\n\n\nacc <- c(\"40100\", \"40401\", \"40700\", \"41100\", \"41200\")   # 매출 계정 모음\n\nje_tbl %>% \n  filter(ACCTCD %in% acc) %>% \n  mutate(ACCTCD = as.factor(ACCTCD)) %>% \n  ggplot(aes(x=ACCTCD, y=CR))+\n    geom_boxplot()\n\n\n제품매출 거래처 갯수 확인\n\n\nje_tbl %>%\n  filter(ACCT_NM == '제품매출') %>% \n  select(`거래처[코드]`) %>% \n  distinct(`거래처[코드]`) %>% \n  count()\n\n\n원재료비 월별 추세 분석\n\n\nacc = '50100'\n\nje_tbl %>% \n  filter(ACCTCD==acc) %>% \n  mutate(month = as.factor(month(JEDATE))) %>% \n  summarise(\n    amount = sum(DR),\n    .by = month\n  ) %>% ggplot(aes(x=month, y=amount))+\n  geom_col()+\n  scale_y_continuous(labels = scales::comma)+\n  theme_bw()\n\n\n매출액 MUS(Monetary Unit Selection) Sampling - E/O\nMUS Sampling 함수 설치 및 library Load\n\n\nif(!require(devtools)){install.packages(\"devtools\")}\nif(!require(rsmsampling)){devtools::install_github(\"joy-hhh/rsmsampling\");library(rsmsampling)}\n# ?mus_sampling\n# ?m_ran_sampling\n# ?ran_sampling\n\n\nParameters Setting\n\n\nSR <- \"No\"          ## or  \"Yes\"\nRC <- \"Yes\"         ## or  \"No\"\nPL <- 4             ## \"Analytical.Procedures.Not.Performed\" 4, \"High\" 1, \"Low\" 2, \"Moderate\" 3 \nam <- \"CR\"          ## 금액열 지정\n\n## 수행중요성 금액 및 허용오류율(5% 등) 입력\nPM <- 700000000     ## Tolerable misstatement (generally performance materiality)\nEA <- 0.05          ## Expected misstatement\n\n\n모집단 filter 및 Sampling 수행\n\n\n## Define Population\nacc <- c(\"40100\", \"40401\", \"40700\", \"41100\", \"41200\")  # 총 매출 계정 모음\n\npopulation <- je_tbl %>% \n  filter(ACCTCD %in% acc)\n\n## 함수 실행\nsampling <- mus_sampling(population, am, SR, RC, PL, PM, EA) # population : 샘플링 대상 모집단\n\n## 샘플링 내역 확인\nprint(sampling, n = Inf)\n\n## 추출된 샘플 엑셀 파일 생성\nsampling %>% write_xlsx(\"MUS_sample.xlsx\")\n\n\n매출액 Cut-off Test Sampling - C/O\n12월 매출액에 대하여 Cut-off 목적으로 Test Sampling\n\n\n## Define Population\nacc <- c(\"40100\", \"40401\", \"40700\", \"41100\", \"41200\")  # 총 매출 계정 모음\n\nco_sampling <- je_tbl %>% \n  filter(ACCTCD %in% acc) %>% \n  filter(month == 12) %>% \n  ran_sampling(30)\n\n## MUS sampling과 중복 항목 제거\nco_sampling <- co_sampling %>% \n  filter(!JENO %in% sampling$JENO)\n\nco_sampling\n\nco_sampling %>% write_xlsx(\"CO_sample.xlsx\")\n\n\n분개장 전표에서 매출 계정별 원장 추출 - 엑셀로 저장\n\n\nacc <- c(\"40100\", \"40401\", \"40700\", \"41100\", \"41200\")\n\nje_tbl %>% \n  filter(ACCTCD %in% acc) %>%\n  split(.$ACCT_NM) %>% \n  write_xlsx(path = \"revenue_gl.xlsx\")\n\n\n\n원래 utf-8 encoding 형식으로 되어 있는 파일을 , locale=locale(‘ko’,encoding=‘euc-kr)’ 없이 읽으면 훨씬 더 빠르게 읽는다. 파일 형식에 대한 전환 과정이 필요 없기 때문이다. 대용량의 전표를 받아서 test 할 때는 utf-8 encoding 형식으로 요청하는 것이 좋은 방법이다.↩︎\n[네이버 지식백과] 벤포드의 법칙↩︎\n",
      "last_modified": "2024-04-20T15:57:38+09:00"
    },
    {
      "path": "index.html",
      "title": "R for Journal Entry Analysis",
      "description": "Welcome. I hope you enjoy it!\n",
      "author": [],
      "contents": "\n● 3회 - 2024년 5월 (Offline)\nPrerequisite\nRstudio R | Docker | Rocker | 윈도우즈에서 도커로 Rstudio 환경 사용하기 | tidyverse 에 따라서 설치한다.\nR 기초 강의 를 시청하고 최대한 따라서 입력 및 실행해 본다.\n\n\n\n오전 Session\nRstudio R | Docker | Rocker | 윈도우즈에서 도커로 Rstudio 환경 사용하기 | tidyverse 설치 확인\n오늘의 할 일 - 빠르게 전체 Process (숲을 보고 결과물 확인)\nrmarkdown과 Quarto 소개\nR and Quarto - qmd 파일에 R코딩 해보기 (Analisys를 위하여 사용한 프로그램 - R.version)\nJournal Entry Analisys - A01 (사전준비, 열 이름 정돈, 날짜형, Factor, Character, skimr)\nJournal Entry Analisys - A02 (차변 대변 차이 확인)\n설명 대상\nVariable assign\nPipe operator\ndplyr(select, , group_by, summarise, mutate, rename)\n점심식사\n정규 연수가 아니므로 점심식사가 제공되지 않는 바 양해 부탁드립니다. 각자 주변 식당(“서울역 게이트웨이타워 식당”을 검색하면 정보를 얻기 쉽습니다.)을 이용해 주시기 바랍니다.\n오후 Session\nJE data 다루기 실습 계속 - A03\nJE data 다루기 실습 계속 - B01\n시각화 (ggplot2)\n질의 응답\n설명 대상\ndplyr(slice, left_jon, semi_join, mutate_all, distinct, pull, arrange, bind_rows),\nstringr(str_detect)\nggplot2(geom_bar, geom_col) , base(prop.table, split)\nFurther study\n챗GPT 코딩\n챗GPT 쿼토\nR 을 활용한 데이터과학 2e\n● 2회 - 2021년 10월 22일 (Online in Teams)\n진행 순서\n\n\n\nRequest\nRstudio - Cheat Sheets 소개 (dplyr, rmarkdown한글)\nrmarkdown\n새로운 JE data에 Rmarkdown code 적용 시연\n질의 응답\nJE Tester by Joy 소개하기\nJournal Entry Tester by Joy 0.1.0\nFurther study\nR 을 활용한 데이터과학\n● 1회 - 2021년 8월 19일 (Online in Teams)\n진행 순서\n인사 및 사전 준비 확인 -Short\n빠르게 전체 Process\n하나씩 따라하기\n숙제 검사\nR 소개와 할 수 있는 것 장점 등\n소감 발표\nFurther study\nMust Learning with R\n재현가능한 과학적 분석을 위한 R\nBOOKDOWN\nR을 이용한 퀀트 투자 포트폴리오 만들기\n\n조이회계 Joy Accounting\nhttps://joy-accounting.netlify.com/\n\n\n\n",
      "last_modified": "2024-04-20T15:57:38+09:00"
    },
    {
      "path": "request.html",
      "title": "Request",
      "description": "Data Request Form for Journal Entry Analysis \n",
      "author": [],
      "date": "`r Sys.Date()`",
      "contents": "\nencoding\nutf-8\nJournal Entry Data Request\n본 Journal Entry 감사 절차는 재무제표에 대한 회계감사의 일환으로서, 회사의 직전 회계연도 시산표 금액과 당해 회계연도의 시산표 금액의 변동사항에 대하여 다음과 같은 기중의 전표데이터를 입수하여 분석하는 것입니다.\n회사의 직전 회계연도 말의 시산표(TB) 금액 = 직전 회계연도의 감사보고서 상의 재무제표 금액\n당해 회계연도 말의 시산표(TB) 금액 = 기말감사 시, 회계법인에 제공하는 감사대상 재무제표 금액\n기중(기표일자 기준)의 전표데이터\n① 전기말TB ± ③ = ② 당기말TB\n따라서 기표일자 기준으로 당 회계연도에 귀속되는 모든 전표데이터를 입수하여 전기 재무제표 금액에 기중 전표데이터 변동사항을 가감했을 경우, 당해 회계연도의 재무제표 금액과 일치하여야 합니다. 본 감사절차를 수행하기 위하여 다음과 같은 데이터를 요청 드립니다.\nPeriod of Journal Entry Data\n일반적으로 전표작성과 관련된 일자(date)개념으로 네 가지(증빙일자(Invoice 또는 세금계산서일자), 전표작성일자, 전표승인일자, 전표기표일자)가 있습니다.\n이 중에서 회사의 재무제표는 전표기표일자(Posting Date)를 기준으로 월 결산 및 회계연도 결산이 수행되어 재무제표가 산출됩니다. 본 감사절차는 재무제표에 대한 회계감사의 일환으로 수행하는 업무이므로, 기표일자(Posting Date)를 기준으로 데이터를 입수하여야 하여, 당 회계연도의 재무제표에 반영되는 모든 전표데이터를 요청 드립니다.\nFormat of Journal Entry Data\n요청 드리는 모든 데이터의 형식은 다음과 같습니다.\n데이터 형식 : delimited text file 입니다. text형식으로 추출해 주시기 바랍니다.\n필드 구분자 : ,(Comma) 또는 Tab 또는 | (구분자는 실제 데이터에는 존재하지 않는 것이어야 합니다. 해당 구분자가 실제 데이터와 중복되는 경우에는 별도의 구분자로 필드를 구분해 주시기 바랍니다)\n데이터의 첫 행(First record line) : 필드레이아웃(Layout) Name. 요청 드리는 데이터의 첫 행에는 필드레이아웃(Layout)명칭을 입력해 주시기 바랍니다. 해당 Record는 각 필드의 name으로 활용하게 됩니다.\n데이터 추출방법에 대한 기술서 : data를 추출하기 위해서 사용한 프로그램, Script, Queries를 그대로 복사해서 제시해 주시면 됩니다. 해당 기술서는 회사에서 데이터를 완전하고 정확하게 데이터를 추출하여 감사 수행 시에 제시했음을 표명하는 자료입니다.\n주의사항 : 요청 드리는 text데이터에는 추출된 실제 데이터 이외에 임의적인 데이터를 입력하면 안됩니다.\nTransfer of Journal Entry Data\n일반적으로 요청 드리는 데이터는 이메일을 통해 전달될 수도 있으나, 용량이 큰 경우가 대부분으로서 이동형저장장치, 외장하드를 통해서 감사수행시 전달됩니다.\nData Request\n아래의 데이터테이블을 요청드립니다.\nTable Number\nTable Name\nTable 1)\nJournal Entries from the General Ledger (Posting Date:2021.1.1~2021.12. 31)\nTable 2)\nPrior Year TB(Trial Balance) (Posting Date:2020.12.31)\nTable 3)\nCurrent Year TB(Trial Balance) (Posting Date:2021.12.31)\nTable 4)\nCOA(Chart of Account) (Posting Date:2021.12.31)\nTable 5)\nHR Information (Posting Date:2021.12.31)\nTable 6)\nTable Layout Description(Excel)\nTable 7)\nFinancial Statements\nTable 8)\n특수관계자\n데이터 테이블의 상세내역은 다음과 같습니다.\n1) Journal Entries from the General Ledger (Posting Date:2021.1.1~2021.12. 31) 전표\nRequired Fields\nField Description\n전표번호(Journal entry header Number)\n회계전표가 처리될 때에 각 회계전표에 대하여 General Ledger로부터 부여 받는 고유번호입니다.\n전표라인번호(Journal entry line number)\n회계전표가 처리될 때에 각 회계전표의 Line Item에 부여되는 번호입니다. 회계전표내의 개별항목번호를 의미합니다.\n총계정원장번호(GLAccount Number)\n총계정원장계정의 계정번호를 의미합니다. COA(Chart of Account)의 총계정원장계정 번호와 동일한 번호를 의미합니다(최소단위의 계정번호입니다)\n총계정원장계정명(GLAccount Name)\n총계정원장계정의 계정명을 의미합니다. COA(Chart of Account)의 총계정원장계정명과 동일한 이름을 의미합니다(최소단위의 계정명입니다)\n전표상태(Entry Status)\n회계전표가 전기되었는지 전기되지 않았는지를 식별해주는 구분자를 의미합니다. (Note:구분자가 코드로 입력되어 있으면, 이를 설명해줄 수 있는 별도의 엑셀파일을 제출해주시기 바랍니다)\n전표입력자(UserName/ Process Name)\nGeneral Ledger에 전표입력을 수행한 사용자ID입니다.(전표입력이 시스템 프로세스에 의해서 이루어지는 전표 건에 대해서는 프로세스 명을 의미합니다)\n전표승인자(Approved by User Name)\n회계전표를 승인한 사용자ID입니다(전표승인이 시스템프로세스에 의해서 자동승인되는 건에 대해서는 프로세스 명을 의미합니다)\n증빙일자(Evidence Date)\n회계전표 작성시에 입력하는 관련 증빙일자를 의미합니다(ex:세금계산서일자)\n전표입력일(Entry Date)\n회계전표를 입력할 때에 시스템에서 생성되는 timestamp를 의미합니다.\n전표승인일(Approved Date)\n입력된 회계전표에 대하여 전표승인자가 승인한 최종승인일자를 의미합니다.\n전표기표일(Posting Date)\n입력 및 승인된 회계전표가 General Ledger에 전기된 (시스템에 의해서 생성된) timestamp를 의미합니다.\n회계기간(Accounting Period)\n입력 및 승인된 회계전표가 General Ledger에 전기된 (시스템에 의해서 생성된) “월”을 의미합니다.\n차변대변지시자\n차변(Debit), 대변(Credit)을 식별하는 구분자를 의미합니다.\n차변금액(Debit Amount)\n각 총계정원장계정번호(명)에 해당하는 차변금액을 의미합니다(차변대변지시자가 존재하는 경우 차변금액은 일반적으로 + 금액이지만, 차변에 – 금액이 입력된 경우에는 – 금액 그대로 표시됩니다)\n대변금액(Credit Amount)\n각 총계정원장계정번호(명)에 해당하는 대변금액을 의미합니다(차변대변지시자가 존재하는 경우 대변금액도 일반적으로 + 금액이지만, 대변에 – 금액이 입력된 경우에는 – 금액 그대로 표시됩니다)\n통화키(Currency Key)\n회계전표에 입력된 각각의 차변/대변금액의 통화를 의미합니다 (ex : KRW, US$)\n전표유형(Type of Entry)\n생성된 회계전표가 General Ledger에 Manual로 입력이 되었는지, 또는 시스템의 다른 모듈(Module)에서 생성되어 General Ledger에 입력되었는지를 식별해주는 구분자(전표Source)를 의미합니다(ex : manual, Fixed Asset system, Accounts Payable system 등) (Note:구분자가 코드로 입력되어 있으면, 이를 설명해줄 수 있는 별도의 엑셀파일을 제출해주시기 바랍니다)\n전표속성(Journal Type)\nJournal Entry가 발생되는 속성에 따라서 one time entry, recurring entry, accrual entry, reversing entry(또는 자산일반전표, 자금결산전표, 감가상각비전표 등)인지를 식별해주는 구분자를 의미합니다. (Note : 구분자가 코드로 입력되어 있으면, 이를 설명해줄 수 있는 별도의 엑셀파일을 제출해주시기 바랍니다)\n비용귀속부서(Cost Center)\n회계전표의 비용이 귀속되는 부서(Cost Center)를 의미합니다. (Note : 귀속부서데이터가 코드로 입력되어 있으면, 코드별로 한글 부서명이 표시되어 있는 별도의 엑셀파일을 제출해주시기 바랍니다)\n고객번호(Customer Number)\n회계전표의 각 총계정원장계정의 거래로 인한 고객처번호를 의미합니다(ex : 매출계정을예로 들면 매출이 발생한 경우, 매출거래의 상대방 고객처를 의미합니다) (Note : 고객처번호에 해당하는 고객처명이 표시되어 있는 별도의 엑셀화일을 제출해주시기 바랍니다)\n구매처번호(Purchasing Number)\n회계전표의 각 총계정원장계정의 거래로 인한 구매처(거래처)번호를 의미합니다(ex : 매입계정을 예로 들면 매입이 발생한 경우, 매입거래의 상대방 고객처를 의미합니다) (Note : 구매처번호에 해당하는 거래처명이 표시되어 있는 별도의 엑셀화일을 제출해주시기 바랍니다)\n주의사항 : 테이블 Field의 구성은 감사수행시 회사의 현황을 고려하여 변동이 가능하나, 일반적으로 상기의 데이터 field의 구성내역은 기본적으로 구성되어야 합니다.\n2) Prior Year TB(Trial Balance) (Posting Date:2020.12.31) 전기 시산표\nRequired Fields\nField Description\n총계정원장번호(GLAccount Number)\n총계정원장계정의 계정번호를 의미합니다. COA(Chart of Account)의 총계정원장계정 번호와 동일한 번호를 의미합니다.\n총계정원장계정명(GLAccount Name)\n총계정원장계정의 계정명을 의미합니다. COA(Chart of Account)의 총계정원장계정명과 동일한 이름을 의미합니다.\n차변 계정잔액금액(Debit Account Balance)\n전기말의 시산표(TB)금액을 의미합니다. 해당 금액은 전기말의 감사보고서상의 최종 공시금액을 의미합니다.\n차변 계정합계금액(Total Debit Amount)\n전기말의 시산표(TB) 차변 합계 금액을 의미합니다.\n대변 계정합계금액(Total Credit Amount)\n전기말의 시산표(TB) 대변 합계 금액을 의미합니다.\n대변 계정잔액금액(Credit Account Balance)\n전기말의 시산표(TB)금액을 의미합니다. 해당 금액은 전기말의 감사보고서상의 최종 공시금액을 의미합니다.\n주의사항 : 전기말 시산표(TB)금액은 전기말 감사보고서상의 최종 공시금액과 일치하는지 회계팀 담당자와 검토하여 검증이 이루어져야 합니다.\n3) Current Year TB(Trial Balance) (Posting Date:2021.12.31) 당기 시산표\nRequired Fields\nField Description\n총계정원장번호(GLAccount Number)\n총계정원장계정의 계정번호를 의미합니다. COA(Chart of Account)의 총계정원장계정 번호와 동일한 번호를 의미합니다.\n총계정원장계정명(GLAccount Name)\n총계정원장계정의 계정명을 의미합니다. COA(Chart of Account)의 총계정원장계정명과 동일한 이름을 의미합니다.\n차변 계정잔액금액(Debit Account Balance)\n당기말의 시산표(TB)금액을 의미합니다. 해당 금액은 당기말의 감사보고서상의 최종 공시금액을 의미합니다.\n차변 계정합계금액(Total Debit Amount)\n당기말의 시산표(TB) 차변 합계 금액을 의미합니다.\n대변 계정합계금액(Total Credit Amount)\n당기말의 시산표(TB) 대변 합계 금액을 의미합니다.\n대변 계정잔액금액(Credit Account Balance)\n당기말의 시산표(TB)금액을 의미합니다. 해당 금액은 당기말의 감사보고서상의 최종 공시금액을 의미합니다.\n주의사항 : 당기말 시산표(TB)금액은 기말감사시 회계법인에 제공하는 감사대상 재무제표 금액과 일치하는지 회계팀 담당자와 검토하여 검증이 이루어져야 합니다.\n4) COA(Chart of Account) (Posting Date:2021.12.31)\nRequired Fields\nField Description\n총계정원장번호(GLAccount Number)\n총계정원장계정의 계정번호를 의미합니다. COA(Chart of Account)의 총계정원장계정 번호를 의미합니다. 해당 계정번호는 최소단위의 계정번호입니다.\n총계정원장계정명(GLAccount Name)\n총계정원장계정의 계정명을 의미합니다. COA(Chart of Account)의 총계정원장계정명을 의미합니다. 해당 계정번호는 최소단위의 계정명입니다.\n생성일자(Create Date)\n총계정원장계정의 최초생성일자를 의미합니다.\n수정일자(Modification)\n총계정원장계정의 변동사항이 발생한 경우의 수정일자를 의미합니다.\n삭제일자(Delete Date)\n총계정원장계정을 사용하지 않도록 삭제처리한 일자를 의미합니다.\n기타\nCOA테이블의 기타 모든 필드를 요청드립니다.\n주의사항 : 일반적으로 COA테이블은 회사에서 사용하고 있는 전체 데이블 Field에 대하여 요청드립니다.\n5) HR Information (Posting Date:2021.12.31)\nRequired Fields\nField Description\n사용자ID(User ID)\n상기의 “1) Journal Entries from the General Ledger”테이블의 전표입력자, 전표승인자 Field의 사용자ID와 동일한 ID를 의미합니다.\n사용자명(User Name)\n사용자ID에 해당하는 사용자명을 의미합니다. 사용자ID가 시스템을 의미할 경우에는 시스템명을 의미합니다.\n소속부서명(Department)\n사용자가 소속된 부서명을 의미합니다(해당 데이터가 소속코드일 경우에는 한글소속부서명이 표시되어 있는 별도의 엑셀화일을 제출해주셔야 하므로, 소속부서명으로 요청드립니다)\n직급(Position)\n사용자의 해당 소속부서에서의 직급을 의미합니다.\n입사일자(Entering Date)\n사용자의 입사일자를 의미합니다.\n퇴사일자(Entering Date)\n당기 회계연도 중에 퇴사한 사용자의 경우에 퇴사일자를 의미합니다.\n주의사항 : 당 회계연도에 퇴사한 사용자에 대해서는 별도의 테이블로 제출해주셔도 됩니다. 상기의 데이터Field에 대하여 회사의 인사정보정책을 고려하여 변동이 가능하나, “사용자ID”, “사용자명”, “소속부서명”은 필수요청 Field입니다.\n6) Table Layout Description(Excel)\nRequired Fields\nField Description\n필드명(Field Name)\n상기의 1)~5)의 각 테이블을 구성하는 Law Data의 필드명을 의미합니다.\n필드타입(Field Type)\n해당 필드의 속성을 의미합니다(ex:Character…)\n필드길이(Field Length)\n해당 필드의 길이를 의미합니다.\n적요(Description)\n해당 Law Data의 필드명에 대한 기술(한글)을 의미합니다.\n주의사항! : 각 Field에 존재하는 실제 데이터가 코드로 입력되어 있으면, 해당 필드에 존재하는 모든 코드내역에 대한 별도의 테이블을 요청드립니다(ex: AA :자산일반전표, AD:임차보증금전표…)\n7) Financial Statements\n기말감사시에 회계법인에 제시하는 감사대상 재무제표와 동일한 재무제표(대차대조표, 손익계산서)를 요청드립니다.\n8) 특수관계자\n감사보고서의 주석에 공시되는 특수관계자와의 거래와 관련해서 다음과 같은 데이터를 요청드립니다.\nRequired Fields\nField Description\n특수관계자번호(Number)\n감사보고서의 주석에 공시되는 특수관계자와의 거래와 관련된 특수관계자번호(ID)를 의미합니다. 특수관계자에 대한 판단여부는 회계팀 담당자의 검토 부탁 드립니다.\n특수관계자명(Name)\n특수관계자번호에 해당하는 한글명을 의미합니다. 감사보고서의 주석에 공시되는 특수관계자의 이름을 의미합니다.\n총계정원장번호(GLAccount Number)\n총계정원장계정의 계정번호를 의미합니다. COA(Chart of Account)의 총계정원장계정 번호를 의미합니다. 해당 계정번호는 최소단위의 계정번호입니다.\n총계정원장계정명(GLAccount Name)\n총계정원장계정의 계정명을 의미합니다. COA(Chart of Account)의 총계정원장계정명을 의미합니다. 해당 계정번호는 최소단위의 계정명입니다.\n발생금액(Amount)\n손익계정의 경우에는 당기 발생금액을 의미하며, 대차대조표계정의 경우에는 당기말 잔액을 의미합니다.\n주의사항 : “발생금액” Field의 데이터금액은 재무제표 주석의 “특수관계자와의 거래”의 금액과 일치하여야 합니다. 상기의 Filed중에서 회사의 현황을 고려하여 변동이 가능하나, “특수관계자번호”, “특수관계자명”은 필수요청 사항입니다.\n\nJournal Entry Analysis\nEnd\n\n\n\n",
      "last_modified": "2024-04-20T15:57:39+09:00"
    }
  ],
  "collections": []
}
